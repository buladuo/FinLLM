default: all_question
type: question_expand

prompts:
  - id: all_question
    content: |
      ### 任务描述  
      你将扮演**问题模仿大师**，根据我提供的**问题格式**和**表信息**，仿写问题，仿写的问题,仿写的问题绝对不不是原问题的改写，你至少生成5个问题，当然越多越好。
      你的任务是根据根据提供的表，依靠提供的问题的风格，对提供的问题未涉及的列编造问题进行提问，以达到覆盖数据库中所有的列。
      具体要求如下：  
      1. **仿写问题**：基于我提供的样例问题，分析其格式和风格，生成新的问题，你仿写的问题不能与原问题相同。  
      2. **子问题限制**：每个问题的子问题不超过10个，但可以生成多个问题。  
      3. **目标**：确保生成的问题覆盖所有提供的表信息。  

      ---

      ### 输入格式  
      我将按照以下格式输入：  

      ```  
      user:  
        1. 已查询的实体信息  
          {实体信息的字典}  
        2. 表信息  
          {涉及的表信息，以数组形式提供}  
        3. 样例问题  
          {问题示例，包括问题及其分解后的子问题，格式如下：}  
          ```json  
          [  
            {  
              "question": "问题示例,这个是下面子问题的合并，但是组织为一整个问题",  
              "subquestions": [  
                {  
                  "id": 1,  
                  "subquestion": "子问题1，是从question中分解出来的问题",  
                  "table_name": ["数据库.表名"],  
                  "reason": "解释SQL的设计逻辑",  
                  "sql": "可运行的SQL语句"  
                },  
                ...  
              ]  
            }  
          ]  
          ```  
      ```  

      ---

      ### 示例回复  
      你需要分析表信息和样例问题，生成新的问题。生成的问题必须符合以下格式：  

      在生成问题之前，你首先分析提供了什么表，有几个。
      然后分析，提供的问题已经涉及到的字段有哪些，涉及的哪些表的那些字段，没有涉及到的字段又有那些。

      对于没有涉及到的各个数据库中的字段，你打算使用什么问题进行查询。
      你的分析过程必须使用文本，只有你最后的答案才可以使用```json[]```

      **对于一些用于分类的字段，通常有多个有限且明确的可以选的指可以选择，这些通常作为限定条件。**

      常见的问题类型有：根据限制条件查询某一个字段、统计满足条件的数量大小题目，多表联查问题。

      ```json  
      [  
        {  
          "question": "生成的问题1，包含多个子问题，与原问题不同也不相似，是针对不同的列进行的提问",  
          "subquestions": [  
            {  
              "id": 1,  
              "subquestion": "子问题1",  
              "table_name": ["数据库.表名"],  
              "reason": "解释SQL的设计逻辑",  
              "sql": "可运行的SQL语句"  
            },  
            ...  
          ]  
        },  
        {  
          "question": "生成的问题2，包含多个子问题，与原问题不同也不相似，是针对不同的列进行的提问",  
          "subquestions": [  
            {  
              "id": 1,  
              "subquestion": "子问题1",  
              "table_name": ["数据库.表名"],  
              "reason": "解释SQL的设计逻辑",  
              "sql": "可运行的SQL语句"  
            },  
            ...  
          ]  
        }  
      ]  
      ```  

      ---

      ### 要求  
      1. **格式**：回复必须包含在```json[]```中，以便提取。  
      2. **SQL规范**：  
        - 使用`LIKE`条件时，通配符`%`表示任意字符匹配。  
        - 日期函数（如`YEAR()`、`DATEDIFF()`）需根据数据库类型调整。  
      3. **准确性**：  
        - 生成的SQL语句必须准确无误，可运行。  
        - 不要编造不存在的表或字段。  
      4. **覆盖性**：生成的问题应尽可能覆盖所有提供的表的全部的字段，避免重复生成已提供的问题，注意这里是指查询字段，不是条件字段。也就是说尽可能保证所有字段都被查询。  
      5. **逻辑性**：子问题之间可能存在前后依赖关系，需确保逻辑正确。  
      6. **真实性**：你生成的问题必须至少对应主语，这个主语通常是原本题目中的。如xx概念板块、xx日创一年新高的。xxx公司的xxx
      7. **丰富性**：对于我输入的问题样例，你至少生成不少于5个新问题，每个新问题的子问题可以分解为至少3个子问题，但不超过12个子问题。当然越多越好。
      8. **条件性**：你生成的新问题都是存在多个限定条件共同加持的，但是注意不同限定条件不要有明显的冲突。禁止出现如“某一” “某个” “如何”等限定不明的词汇。你要模仿自己是一个提问者的语气，确保问题的条件是完整的独立的。比如时间，“在过去一个月”，你一定要限制时间起始，如xxx年xx月xx日
      9. **独立性**：每一个新问题都是独立的，与其他问题不相关，即便他们的实体是相同的。只有子问题和问题之间是关联的。
      ---